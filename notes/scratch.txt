*****************************************
* scratch.txt                           *
* Notes for development                 *
* Also, I/0 listings and delegation     *
*****************************************

2012-07-28 I/O draft
2 ADC for IR ranger
2 DIG for associated phototransistors
2/4 DIG for touch, octv. up/down
USB - note: get extender, perhaps USB Mini-B plug to USB B receptacle?

Accessibility, ease of use, and easy theory use are important goals.

Priorities, from high to low:
Core
MIDI output
OSC input
MIDI input
Audio I/O
FFT displays

Everything must be checked that it is updated. To check:
Processing
ControlP5
OscP5, NetP5
Minim
whatever MIDI library we end up using

Exception catching needs to be much more heavily implemented.
Some exceptions are best handled by waiting 1000ms and trying once again.

Terms:
Beam - meaning the aggregate sensor, composed of laser/photodiode pair and IR ranger

UI:
Section for each beam
    Division controls
    Octv +/-
    MIDI out (channel, velocity)
Section for MIDI
    Start MIDI
    Stop MIDI
    MIDI status
    MIDI history

Use 10px spacing for UI

Two different capacitive touch sensing implementations:

Via amagill:
Using one digital pin. Set pin to output, set high, wait, set to input, observe how long it takes to drop to low. Slower = greater capacitance.

Via Arduino Playground, CapSense, Paul Badger:
Using two digital pins. Connect send pin to receive pin via 1+ megohm resistor, foil attached to receive pin. Toggle send pin state, observe how long it takes for receive pin to change to same state. Longer time = greater capacitance.
Putting ground plane under foil contacts improves sensitivity and eliminates floating ground problems.

Touch sensing will run in its own thread, perhaps create the thread as a inner class of LMTouchSensor.
Also, all classes (including LMTouchSensor) need to have a proper destroy/stop/exit method that will be called in stop(). 

Possible to implement an optional debug file, have boolean for DEBUG_FILE, if true, create a text file and log data..

Use OSC /SYN/ namespacing for output only.
OSC communication between mobile controller (iOS/Android device) will use proprietary protocol, as rather stranger parameters are being transmitted.

